{"version":3,"sources":["CanvasExamples/CanvasUtils.ts","CanvasExamples/ColoredPixels.ts","CanvasExamples/DotPattern.ts","CanvasExamples/Rainbow.ts","CanvasExample.tsx","CanvasExamples/Fur.ts","CanvasExamples/ImagePattern.ts","CanvasExamples/Shadows.ts","CanvasExamples/Shapes.ts","CanvasExamples/SimplePencil.ts","CanvasExamples/Spray.ts","App.js","reportWebVitals.js","index.js"],"names":["getCoordinates","canvas","event","positionX","positionY","rect","changedTouches","console","log","pageX","pageY","nativeEvent","x","y","drawLine","originalPosition","newPosition","color","size","context","getContext","strokeStyle","lineJoin","lineWidth","beginPath","moveTo","lineTo","closePath","stroke","drawShadedLine","shadowBlur","shadowColor","lineCap","useColoredPixels","useState","isDrawing","setIsDrawing","draw","canvasRef","coordinates","min","max","ctx","i","j","Math","random","fillStyle","floor","fillRect","drawPixels","exitDraw","startDraw","useDotPattern","canDraw","setCanDraw","position","setPosition","points","setPoints","midPointBtw","p1","p2","newCoordinates","push","len","length","midPoint","quadraticCurveTo","restore","save","patternCanvas","document","createElement","patternCtx","width","height","dotWidth","arc","PI","fill","createPattern","getPattern","currentPoints","useRainbow","hue","setHue","lastX","setLastX","lastY","setLastY","rgb","h","s","l","r","g","b","hue2rgb","p","q","t","round","hslToRgb","CanvasExample","props","comingFromMobile","window","React","useRef","strokeType","setStrokeType","coloredPixels","dotPattern","fur","dx","dy","d","useFur","imagePattern","clearRect","img","Image","onload","src","useImagePattern","rainbow","shadows","useShadows","shapes","drawStar","translate","rotate","useShapes","simplePencil","useSimplePencil","spray","density","getRandomInt","offsetX","offsetY","useSpray","_","camelCase","current","ref","style","backgroundColor","onTouchStart","evt","onTouchMove","onTouchEnd","onMouseDown","onMouseMove","onMouseUp","onClick","ReactNativeWebView","postMessage","alert","activityId","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","getElementById","hasChildNodes","ReactDOM","hydrate","StrictMode","render"],"mappings":"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","file":"static/js/main.aa4cf5b3.chunk.js","sourcesContent":["export const canvasHeight = 400;\nexport const canvasWidth = 400;\n\nexport interface Position {\n  x?: number;\n  y?: number;\n}\n\nexport const getCoordinates = (canvas, event) => {\n  if (!canvas || !event) {\n    return {};\n  }\n  const rect = { left: 0, top: 0 };\n\n  let positionX;\n  let positionY;\n\n  // First check if it is a touch event.\n  // Tricky because GCanvas uses event.nativeEvent object,\n  // while web canvas uses event.changedTouches (array, position 0).\n  if (event.changedTouches) {\n    console.log(\"#1\");\n    // Web Canvas touch\n    positionX = event.changedTouches[0]?.pageX;\n    positionY = event.changedTouches[0]?.pageY;\n  } else if (event.nativeEvent?.pageX && event.nativeEvent?.pageY) {\n    // Either Mobile GCanvas touch or Web Canvas mouse click\n    positionX = event.nativeEvent?.pageX;\n    positionY = event.nativeEvent?.pageY;\n  } else {\n    // Shouldn't happen (being super safe to catch a web Canvas mouse click)\n    console.log(\"#3\");\n    positionX = event.pageX;\n    positionY = event.pageY;\n  }\n\n  return {\n    x: positionX - rect.left,\n    y: positionY - rect.top,\n  };\n};\n\nexport const drawLine = (\n  canvas,\n  originalPosition,\n  newPosition,\n  color,\n  size\n) => {\n  if (!canvas) {\n    return;\n  }\n  const context = canvas.getContext(\"2d\");\n\n  console.log(\"context\");\n\n  console.log(context);\n\n  if (context) {\n    context.strokeStyle = color || \"#FF0000\";\n    context.lineJoin = \"round\";\n    context.lineWidth = size || 5;\n    context.beginPath();\n    context.moveTo(originalPosition.x, originalPosition.y);\n    context.lineTo(newPosition.x, newPosition.y);\n    context.closePath();\n    context.stroke();\n  }\n};\n\nexport const drawShadedLine = (\n  canvas,\n  originalPosition,\n  newPosition,\n  color,\n  size\n) => {\n  if (!canvas) {\n    return;\n  }\n  const context = canvas.getContext(\"2d\");\n  if (context) {\n    context.strokeStyle = color || \"#FF0000\";\n    context.shadowBlur = size || 10;\n    context.shadowColor = \"rgb(0,0,0)\";\n    context.lineCap = \"round\";\n    context.lineJoin = \"round\";\n    context.lineWidth = size || 5;\n    context.beginPath();\n    context.moveTo(originalPosition.x, originalPosition.y);\n    context.lineTo(newPosition.x, newPosition.y);\n    context.closePath();\n    context.stroke();\n  }\n};\n","import { useState } from 'react';\nimport { getCoordinates } from './CanvasUtils';\n\nexport function useColoredPixels() {\n  const [isDrawing, setIsDrawing] = useState(false);\n\n  const getRandomInt = (min, max) => {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  };\n\n  const drawPixels = (canvasRef, x, y) => {\n    const ctx = canvasRef.getContext('2d');\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round';\n    for (let i = -10; i < 10; i += 4) {\n      for (let j = -10; j < 10; j += 4) {\n        if (Math.random() > 0.5) {\n          ctx.fillStyle = ['red', 'orange', 'yellow', 'green', 'light-blue', 'blue', 'purple'][\n            getRandomInt(0, 6)\n          ];\n          ctx.fillRect(x + i, y + j, 4, 4);\n        }\n      }\n    }\n  };\n\n  const startDraw = (canvasRef, event) => {\n    const coordinates = getCoordinates(canvasRef, event);\n    setIsDrawing(true);\n  };\n\n  const draw = (canvasRef, event) => {\n    if (isDrawing) {\n      const coordinates = getCoordinates(canvasRef, event);\n      drawPixels(canvasRef, coordinates.x, coordinates.y);\n    }\n  };\n\n  const exitDraw = () => {\n    setIsDrawing(false);\n  };\n\n  return {\n    draw,\n    exitDraw,\n    startDraw\n  };\n}\n","import { useState } from \"react\";\nimport {\n  canvasHeight,\n  canvasWidth,\n  drawShadedLine,\n  getCoordinates,\n  Position,\n} from \"./CanvasUtils\";\n\nexport function useDotPattern() {\n  const [canDraw, setCanDraw] = useState(false);\n  const [position, setPosition] = useState<Position | null>(null);\n  const [points, setPoints] = useState<any>([]);\n\n  function midPointBtw(p1, p2) {\n    return {\n      x: p1.x + (p2.x - p1.x) / 2,\n      y: p1.y + (p2.y - p1.y) / 2,\n    };\n  }\n\n  function getPattern(canvasRef: any) {\n    const patternCanvas = document.createElement(\"canvas\"),\n      dotWidth = 20,\n      dotDistance = 5,\n      patternCtx = patternCanvas.getContext(\"2d\");\n\n    patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;\n\n    patternCtx.fillStyle = \"red\";\n    patternCtx.beginPath();\n    patternCtx.arc(\n      dotWidth / 2,\n      dotWidth / 2,\n      dotWidth / 2,\n      0,\n      Math.PI * 2,\n      false\n    );\n    patternCtx.closePath();\n    patternCtx.fill();\n    const ctx = canvasRef.getContext(\"2d\");\n    return ctx.createPattern(patternCanvas, \"repeat\");\n  }\n\n  const startDraw = (canvasRef, event) => {\n    const coordinates = getCoordinates(canvasRef, event);\n    if (coordinates && coordinates.x && coordinates.y) {\n      const context = canvasRef.getContext(\"2d\");\n      context.save();\n\n      setCanDraw(true);\n      setPosition(coordinates);\n\n      context.lineWidth = 25;\n      context.lineCap = \"round\";\n      context.lineJoin = \"round\";\n      context.strokeStyle = getPattern(canvasRef);\n\n      setPoints((currentPoints: any) => [\n        ...currentPoints,\n        { x: coordinates.x, y: coordinates.y },\n      ]);\n    }\n  };\n\n  const draw = (canvasRef, event) => {\n    if (canDraw) {\n      const newCoordinates = getCoordinates(canvasRef, event);\n      if (position && newCoordinates) {\n        const context = canvasRef.getContext(\"2d\");\n        points.push({ x: newCoordinates.x, y: newCoordinates.y });\n\n        //        context.clearRect(0, 0, canvasWidth, canvasHeight);\n\n        var p1 = points[0];\n        var p2 = points[1];\n\n        context.beginPath();\n        context.moveTo(p1.x, p1.y);\n\n        for (var i = 1, len = points.length; i < len; i++) {\n          var midPoint = midPointBtw(p1, p2);\n          context.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);\n          p1 = points[i];\n          p2 = points[i + 1];\n        }\n        context.lineTo(p1.x, p1.y);\n        context.stroke();\n      }\n    }\n  };\n\n  const exitDraw = (canvasRef?: any) => {\n    setCanDraw(false);\n    points.length = 0;\n    if (canvasRef) {\n      const context = canvasRef.getContext(\"2d\");\n      context.restore();\n    }\n  };\n\n  return {\n    draw,\n    exitDraw,\n    startDraw,\n  };\n}\n","import { useState } from 'react';\nimport { getCoordinates } from './CanvasUtils';\n\nexport function useRainbow() {\n  const [isDrawing, setIsDrawing] = useState(false);\n  const [hue, setHue] = useState<any>([]);\n  const [lastX, setLastX] = useState<any>(null);\n  const [lastY, setLastY] = useState<any>(null);\n\n  function hslToRgb(h, s, l) {\n    //convert h, s, and l back to the 0-1 range\n    //convert the hue's 360 degrees in a circle to 1\n    h /= 360;\n    //convert the saturation and lightness to the 0-1\n    //range by multiplying by 100\n    s /= 100;\n    l /= 100;\n    let r;\n    let g;\n    let b;\n    if (s === 0) {\n      r = l;\n      g = l;\n      b = l;\n    } else {\n      const hue2rgb = function hue2rgb(p, q, t) {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1 / 6) return p + (q - p) * 6 * t;\n        if (t < 1 / 2) return q;\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n      };\n\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      const p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1 / 3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - 1 / 3);\n    }\n\n    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n  }\n\n  const startDraw = (canvasRef, event) => {\n    const coordinates = getCoordinates(canvasRef, event);\n    setIsDrawing(true);\n    setLastX(coordinates.x);\n    setLastY(coordinates.y);\n  };\n\n  const draw = (canvasRef, event) => {\n    if (isDrawing) {\n      const ctx = canvasRef.getContext('2d');\n      const coordinates = getCoordinates(canvasRef, event);\n      ctx.lineCap = 'round';\n      ctx.lineJoin = 'round';\n      ctx.lineWidth = 33;\n      const rgb = hslToRgb(hue, 100, 50);\n      ctx.strokeStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;\n      ctx.beginPath();\n      ctx.moveTo(lastX, lastY);\n      ctx.lineTo(coordinates.x, coordinates.y);\n      ctx.stroke();\n      setHue(hue + 1);\n      if (hue >= 360) {\n        setHue(1);\n      }\n      setLastX(coordinates.x);\n      setLastY(coordinates.y);\n    }\n  };\n\n  const exitDraw = () => {\n    setIsDrawing(false);\n  };\n\n  return {\n    draw,\n    exitDraw,\n    startDraw\n  };\n}\n","/* eslint-disable react/button-has-type */\nimport _ from 'lodash';\nimport React from 'react';\nimport { canvasHeight, canvasWidth } from './CanvasExamples/CanvasUtils';\nimport { useColoredPixels } from './CanvasExamples/ColoredPixels';\nimport { useDotPattern } from './CanvasExamples/DotPattern';\nimport { useFur } from './CanvasExamples/Fur';\nimport { useImagePattern } from './CanvasExamples/ImagePattern';\nimport { useRainbow } from './CanvasExamples/Rainbow';\nimport { useShadows } from './CanvasExamples/Shadows';\nimport { useShapes } from './CanvasExamples/Shapes';\nimport { useSimplePencil } from './CanvasExamples/SimplePencil';\nimport { useSpray } from './CanvasExamples/Spray';\n\ndeclare const window: any;\n\nconst CanvasExample = (props: any) => {\n  const { comingFromMobile } = window;\n\n  const canvasRef: any = React.useRef(null);\n\n  // React State\n  const [strokeType, setStrokeType] = React.useState('simplePencil');\n\n  // Examples Hooks\n  const coloredPixels = useColoredPixels();\n  const dotPattern = useDotPattern();\n  const fur = useFur();\n  const imagePattern = useImagePattern();\n  const rainbow = useRainbow();\n  const shadows = useShadows();\n  const shapes = useShapes();\n  const simplePencil = useSimplePencil();\n  const spray = useSpray();\n\n  const onCanvasCreate = (canvas: any) => {\n    if (canvasRef.current) {\n      return;\n    }\n    canvasRef.current = canvas;\n    //      canvasRef.current.width = canvasRef.current.clientWidth;\n    //      canvasRef.current.height = canvasRef.current.clientHeight;\n  };\n\n  const startDraw = (event: any) => {\n    if (_.camelCase(strokeType) === 'simplePencil') {\n      simplePencil.startDraw(canvasRef.current, event);\n    } else if (_.camelCase(strokeType) === 'shadows') {\n      shadows.startDraw(canvasRef.current, event);\n    } else if (_.camelCase(strokeType) === 'coloredPixels') {\n      coloredPixels.startDraw(canvasRef.current, event);\n    } else if (_.camelCase(strokeType) === 'fur') {\n      fur.startDraw(canvasRef.current, event);\n    } else if (_.camelCase(strokeType) === 'rainbow') {\n      rainbow.startDraw(canvasRef.current, event);\n    } else if (_.camelCase(strokeType) === 'shapes') {\n      shapes.startDraw(canvasRef.current, event);\n    } else if (_.camelCase(strokeType) === 'spray') {\n      spray.startDraw(canvasRef.current, event);\n    } else if (_.camelCase(strokeType) === 'dotPattern') {\n      dotPattern.startDraw(canvasRef.current, event);\n    } else if (_.camelCase(strokeType) === 'imagePattern') {\n      imagePattern.startDraw(canvasRef.current, event);\n    }\n  };\n\n  const draw = (event: any) => {\n    if (_.camelCase(strokeType) === 'simplePencil') {\n      simplePencil.draw(canvasRef.current, event);\n    } else if (_.camelCase(strokeType) === 'shadows') {\n      shadows.draw(canvasRef.current, event);\n    } else if (_.camelCase(strokeType) === 'coloredPixels') {\n      coloredPixels.draw(canvasRef.current, event);\n    } else if (_.camelCase(strokeType) === 'fur') {\n      fur.draw(canvasRef.current, event);\n    } else if (_.camelCase(strokeType) === 'rainbow') {\n      rainbow.draw(canvasRef.current, event);\n    } else if (_.camelCase(strokeType) === 'shapes') {\n      shapes.draw(canvasRef.current, event);\n    } else if (_.camelCase(strokeType) === 'spray') {\n      spray.draw(canvasRef.current, event);\n    } else if (_.camelCase(strokeType) === 'dotPattern') {\n      dotPattern.draw(canvasRef.current, event);\n    } else if (_.camelCase(strokeType) === 'imagePattern') {\n      imagePattern.draw(canvasRef.current, event);\n    }\n  };\n\n  const exitDraw = (event: any) => {\n    if (_.camelCase(strokeType) === 'simplePencil') {\n      simplePencil.exitDraw();\n    } else if (_.camelCase(strokeType) === 'shadows') {\n      shadows.exitDraw(canvasRef.current);\n    } else if (_.camelCase(strokeType) === 'coloredPixels') {\n      coloredPixels.exitDraw();\n    } else if (_.camelCase(strokeType) === 'fur') {\n      fur.exitDraw();\n    } else if (_.camelCase(strokeType) === 'rainbow') {\n      rainbow.exitDraw();\n    } else if (_.camelCase(strokeType) === 'shapes') {\n      shapes.exitDraw();\n    } else if (_.camelCase(strokeType) === 'spray') {\n      spray.exitDraw();\n    } else if (_.camelCase(strokeType) === 'dotPattern') {\n      dotPattern.exitDraw(canvasRef.current);\n    } else if (_.camelCase(strokeType) === 'imagePattern') {\n      imagePattern.exitDraw(canvasRef.current);\n    }\n  };\n\n  const buttonContainerStyle = {\n    flexDirection: 'row',\n    flexWrap: 'wrap',\n    justifyContent: 'center',\n    marginTop: '5%',\n  };\n\n  const buttonStyle = {\n    backgroundColor: 'green',\n    marginHorizontal: 5,\n    marginVertical: 10,\n    padding: 10,\n  };\n\n  return (\n    <div>\n      <div>\n        <canvas\n          ref={onCanvasCreate}\n          height={canvasHeight}\n          width={canvasWidth}\n          style={{ backgroundColor: 'yellow' }}\n          onTouchStart={evt => {\n            startDraw(evt);\n          }}\n          onTouchMove={evt => {\n            draw(evt);\n          }}\n          onTouchEnd={evt => {\n            exitDraw(evt);\n          }}\n          onMouseDown={evt => {\n            startDraw(evt);\n          }}\n          onMouseMove={evt => {\n            draw(evt);\n          }}\n          onMouseUp={evt => {\n            exitDraw(evt);\n          }}\n        />\n      </div>\n      <div /*style={styles.buttonContainer}*/>\n        <button\n          onClick={() => {\n            setStrokeType('simplePencil');\n          }}>\n          Simple Pencil\n        </button>\n        <button\n          onClick={() => {\n            setStrokeType('coloredPixels');\n          }}>\n          Colored Pixels\n        </button>\n        <button\n          onClick={() => {\n            setStrokeType('fur');\n          }}>\n          Fur\n        </button>\n        <button\n          onClick={() => {\n            setStrokeType('shadows');\n          }}>\n          Shadows\n        </button>\n      </div>\n      <div>\n        <button\n          onClick={() => {\n            setStrokeType('shapes');\n          }}>\n          Shapes\n        </button>\n        <button\n          onClick={() => {\n            setStrokeType('spray');\n          }}>\n          Spray\n        </button>\n        <button\n          onClick={() => {\n            setStrokeType('dotPattern');\n          }}>\n          Dot Pattern\n        </button>\n        <button\n          onClick={() => {\n            setStrokeType('imagePattern');\n          }}>\n          Image Pattern\n        </button>\n      </div>\n      <div>\n        <button\n          onClick={() => {\n            const context = canvasRef.current?.getContext('2d');\n            context.clearRect(0, 0, canvasWidth, canvasHeight);\n          }}>\n          CLEAR\n        </button>\n        <button\n          onClick={() => {\n            if (comingFromMobile) {\n              window.ReactNativeWebView.postMessage(\n                'React Native Mobile Code to save',\n              );\n            } else {\n              window.alert('React Web Code to save');\n            }\n          }}>\n          SAVE\n        </button>\n      </div>\n      <h3>window.comingFromMobile: {comingFromMobile ? 'true' : 'false'}</h3>\n      <h3>\n        activityId: {comingFromMobile ? window.activityId : props.activityId}\n      </h3>\n    </div>\n  );\n};\n\nexport default CanvasExample;\n","import { useState } from \"react\";\nimport { getCoordinates } from \"./CanvasUtils\";\n\nexport function useFur() {\n  const [isDrawing, setIsDrawing] = useState(false);\n  const [points, setPoints] = useState<any>([]);\n\n  const startDraw = (canvasRef, event) => {\n    const context = canvasRef.getContext(\"2d\");\n    context.save();\n    const coordinates = getCoordinates(canvasRef, event);\n    setPoints([]);\n    setIsDrawing(true);\n    setPoints((currentPoints) => [\n      ...currentPoints,\n      { x: coordinates.x, y: coordinates.y },\n    ]);\n  };\n\n  const draw = (canvasRef, event) => {\n    if (isDrawing) {\n      const ctx = canvasRef.getContext(\"2d\");\n      const coordinates = getCoordinates(canvasRef, event);\n\n      //ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n      setPoints((currentPoints) => [\n        ...currentPoints,\n        { x: coordinates.x, y: coordinates.y },\n      ]);\n\n      const p1 = points[points.length - 2];\n      const p2 = points[points.length - 1];\n      ctx.beginPath();\n      if (p1) {\n        ctx.moveTo(p1.x, p1.y);\n      }\n      if (p2) {\n        ctx.lineTo(p2.x, p2.y);\n      }\n      ctx.stroke();\n\n      for (let i = 0, len = points.length; i < len; i++) {\n        const dx = points[i].x - points[points.length - 1].x;\n        const dy = points[i].y - points[points.length - 1].y;\n        const d = dx * dx + dy * dy;\n\n        if (d < 2000 && Math.random() > d / 2000) {\n          ctx.beginPath();\n          ctx.strokeStyle = \"rgba(0,0,0,0.3)\";\n          ctx.moveTo(\n            points[points.length - 1].x + dx * 0.5,\n            points[points.length - 1].y + dy * 0.5\n          );\n          ctx.lineTo(\n            points[points.length - 1].x - dx * 0.5,\n            points[points.length - 1].y - dy * 0.5\n          );\n          ctx.stroke();\n        }\n      }\n    }\n  };\n\n  const exitDraw = (canvasRef?: any) => {\n    setIsDrawing(false);\n    if (canvasRef) {\n      const context = canvasRef.getContext(\"2d\");\n      context.restore();\n    }\n  };\n\n  return {\n    draw,\n    exitDraw,\n    startDraw,\n  };\n}\n","import { useState } from \"react\";\nimport { getCoordinates, Position } from \"./CanvasUtils\";\n\nexport function useImagePattern() {\n  const [canDraw, setCanDraw] = useState(false);\n  const [position, setPosition] = useState<Position | null>(null);\n  const [points, setPoints] = useState<any>([]);\n\n  function midPointBtw(p1, p2) {\n    return {\n      x: p1.x + (p2.x - p1.x) / 2,\n      y: p1.y + (p2.y - p1.y) / 2,\n    };\n  }\n\n  function getPattern(canvasRef: any, img: any) {\n    const context = canvasRef.getContext(\"2d\");\n    return context.createPattern(img, \"repeat\");\n  }\n\n  const startDraw = (canvasRef, event) => {\n    const coordinates = getCoordinates(canvasRef, event);\n    if (coordinates && coordinates.x && coordinates.y) {\n      const context = canvasRef.getContext(\"2d\");\n      context.save();\n\n      setCanDraw(true);\n      setPosition(coordinates);\n\n      context.lineWidth = 25;\n      context.lineCap = \"round\";\n      context.lineJoin = \"round\";\n\n      const img = new Image();\n      img.onload = function () {\n        context.strokeStyle = getPattern(canvasRef, img);\n      };\n      img.src = \"https://i.imgur.com/huy6X9t.png\";\n\n      setPoints((currentPoints: any) => [\n        ...currentPoints,\n        { x: coordinates.x, y: coordinates.y },\n      ]);\n    }\n  };\n\n  const draw = (canvasRef, event) => {\n    if (canDraw) {\n      const newCoordinates = getCoordinates(canvasRef, event);\n      if (position && newCoordinates) {\n        const ctx = canvasRef.getContext(\"2d\");\n\n        points.push({ x: newCoordinates.x, y: newCoordinates.y });\n\n        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n        var p1 = points[0];\n        var p2 = points[1];\n\n        ctx.beginPath();\n        ctx.moveTo(p1.x, p1.y);\n\n        for (var i = 1, len = points.length; i < len; i++) {\n          var midPoint = midPointBtw(p1, p2);\n          ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);\n          p1 = points[i];\n          p2 = points[i + 1];\n        }\n        ctx.lineTo(p1.x, p1.y);\n        ctx.stroke();\n      }\n    }\n  };\n\n  const exitDraw = (canvasRef?: any) => {\n    setCanDraw(false);\n    points.length = 0;\n    if (canvasRef) {\n      const context = canvasRef.getContext(\"2d\");\n      context.restore();\n    }\n  };\n\n  return {\n    draw,\n    exitDraw,\n    startDraw,\n  };\n}\n","import { useState } from \"react\";\nimport { drawShadedLine, getCoordinates, Position } from \"./CanvasUtils\";\n\nexport function useShadows() {\n  const [canDraw, setCanDraw] = useState(false);\n  const [position, setPosition] = useState<Position | null>(null);\n\n  const startDraw = (canvasRef, event) => {\n    const coordinates = getCoordinates(canvasRef, event);\n    if (coordinates && coordinates.x && coordinates.y) {\n      const context = canvasRef.getContext(\"2d\");\n      context.save();\n      const newX = coordinates.x + 0.1;\n      const newY = coordinates.y + 0.1;\n      // secondPoint hack, because you can't use drawLine with just 1 point\n      const newCoordinates = { x: newX, y: newY };\n      setCanDraw(true);\n      setPosition(coordinates);\n      drawShadedLine(canvasRef, coordinates, newCoordinates, null, null);\n    }\n  };\n\n  const draw = (canvasRef, event) => {\n    if (canDraw) {\n      const newCoordinates = getCoordinates(canvasRef, event);\n      if (position && newCoordinates) {\n        drawShadedLine(canvasRef, position, newCoordinates, null, null);\n        setPosition(newCoordinates);\n      }\n    }\n  };\n\n  const exitDraw = (canvasRef?: any) => {\n    setCanDraw(false);\n    if (canvasRef) {\n      const context = canvasRef.getContext(\"2d\");\n      context.restore();\n    }\n  };\n\n  return {\n    draw,\n    exitDraw,\n    startDraw,\n  };\n}\n","import {useState} from 'react';\nimport {\n  canvasHeight,\n  canvasWidth,\n  getCoordinates,\n  Position,\n} from './CanvasUtils';\n\nexport function useShapes() {\n  const [position, setPosition] = useState<Position | null>(null);\n  const [isDrawing, setIsDrawing] = useState(false);\n  const [points, setPoints] = useState<any>([]);\n  const [radius, setRadius] = useState(15);\n\n  const drawStar = (canvasRef, x, y) => {\n    const length = 15;\n    const ctx = canvasRef.getContext('2d');\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.beginPath();\n    ctx.rotate((Math.PI * 1) / 10);\n    for (let i = 5; i--; ) {\n      ctx.lineTo(0, length);\n      ctx.translate(0, length);\n      ctx.rotate((Math.PI * 2) / 10);\n      ctx.lineTo(0, -length);\n      ctx.translate(0, -length);\n      ctx.rotate(-((Math.PI * 6) / 10));\n    }\n    ctx.lineTo(0, length);\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n  };\n\n  const getRandomInt = (min, max) => {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  };\n\n  const startDraw = (canvasRef, event) => {\n    const coordinates = getCoordinates(canvasRef, event);\n    setIsDrawing(true);\n    setPoints(points => [...points, {x: coordinates.x, y: coordinates.y}]);\n  };\n\n  const draw = (canvasRef, event) => {\n    if (isDrawing) {\n      const newCoordinates = getCoordinates(canvasRef, event);\n\n      setPoints(points => [\n        ...points,\n        {x: newCoordinates.x, y: newCoordinates.y},\n      ]);\n\n      const ctx = canvasRef.getContext('2d');\n      //      ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n\n      for (let i = 0; i < points.length; i++) {\n        drawStar(canvasRef, points[i].x, points[i].y);\n      }\n      /*\n      if (position && newCoordinates) {\n        drawShadedLine(canvasRef, position, newCoordinates, null, null);\n        setPosition(newCoordinates);\n      }\n      */\n    }\n  };\n\n  const exitDraw = () => {\n    setIsDrawing(false);\n    points.length = 0;\n  };\n\n  return {\n    draw,\n    exitDraw,\n    startDraw,\n  };\n}\n","import { useState } from \"react\";\nimport { drawLine, getCoordinates, Position } from \"./CanvasUtils\";\n\nexport function useSimplePencil() {\n  const [canDraw, setCanDraw] = useState(false);\n  const [position, setPosition] = useState<Position | null>(null);\n\n  const startDraw = (canvasRef, event) => {\n    const coordinates = getCoordinates(canvasRef, event);\n    console.log(coordinates);\n    if (coordinates && coordinates.x && coordinates.y) {\n      const newX = coordinates.x + 0.1;\n      const newY = coordinates.y + 0.1;\n      // secondPoint hack, because you can't use drawLine with just 1 point\n      const newCoordinates = { x: newX, y: newY };\n      setCanDraw(true);\n      setPosition(coordinates);\n      drawLine(canvasRef, coordinates, newCoordinates, null, null);\n    }\n  };\n\n  const draw = (canvasRef, event) => {\n    if (canDraw) {\n      const newCoordinates = getCoordinates(canvasRef, event);\n      if (position && newCoordinates) {\n        drawLine(canvasRef, position, newCoordinates, null, null);\n        setPosition(newCoordinates);\n      }\n    }\n  };\n\n  const exitDraw = () => {\n    setCanDraw(false);\n  };\n\n  return {\n    draw,\n    exitDraw,\n    startDraw,\n  };\n}\n","import { useState } from 'react';\nimport { canvasHeight, canvasWidth, getCoordinates, Position } from './CanvasUtils';\n\nexport function useSpray() {\n  const [position, setPosition] = useState<Position | null>(null);\n  const [isDrawing, setIsDrawing] = useState(false);\n  const [density, setDensity] = useState<any>(50);\n\n  const getRandomInt = (min, max) => {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  };\n\n  const startDraw = (canvasRef, event) => {\n    const coordinates = getCoordinates(canvasRef, event);\n    setIsDrawing(true);\n    const ctx = canvasRef.getContext('2d');\n    ctx.lineWidth = 10;\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round';\n    ctx.moveTo(coordinates.x, coordinates.y);\n  };\n\n  const draw = (canvasRef, event) => {\n    if (isDrawing) {\n      const newCoordinates = getCoordinates(canvasRef, event);\n      for (let i = density; i--; ) {\n        const ctx = canvasRef.getContext('2d');\n        const radius = 20;\n        const offsetX = getRandomInt(-radius, radius);\n        const offsetY = getRandomInt(-radius, radius);\n        ctx.fillRect(newCoordinates.x + offsetX, newCoordinates.y + offsetY, 1, 1);\n      }\n    }\n  };\n\n  const exitDraw = () => {\n    setIsDrawing(false);\n  };\n\n  return {\n    draw,\n    exitDraw,\n    startDraw\n  };\n}\n","import React from 'react';\nimport CanvasExample from './CanvasExample';\n\nfunction App() {\n  return <CanvasExample />;\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nconst rootElement = document.getElementById(\"root\");\n\nif (rootElement.hasChildNodes()) {\n  ReactDOM.hydrate(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>,\n    document.getElementById(\"root\")\n  );\n} else {\n  ReactDOM.render(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>,\n    document.getElementById(\"root\")\n  );\n}\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}